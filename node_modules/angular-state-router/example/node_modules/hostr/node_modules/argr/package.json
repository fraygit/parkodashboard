{
  "name": "argr",
  "version": "1.1.7",
  "description": "A command-line argument parser utility designed to parse command-line arguments.",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/henrytseng/argr.git"
  },
  "main": "lib/argr",
  "scripts": {
    "watch": "mocha tests/spec -w",
    "test": "mocha tests/spec"
  },
  "author": {
    "name": "Henry Tseng",
    "email": "contact@henrytseng.com",
    "url": "http://www.henrytseng.com/"
  },
  "keywords": [
    "command-line",
    "commandline",
    "terminal",
    "parser",
    "command",
    "utility",
    "helper",
    "arguments",
    "argv",
    "parameters",
    "cli"
  ],
  "license": "MIT",
  "dependencies": {
    "lodash": "^3.5.0"
  },
  "devDependencies": {
    "jasmine": "^2.2.1",
    "mocha": "~2.2.1"
  },
  "readme": "argr\n====\n\n[![Build Status](https://travis-ci.org/henrytseng/argr.svg)](https://travis-ci.org/henrytseng/argr)\n[![Gitter](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/henrytseng/argr?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge)\n\nA command-line argument parser utility designed to parse command-line arguments.  \n\nUse complex parameters and define a argument signature.  \n\n`command --param value1 value2`\n\nUse compact syntax.  \n\n`command -p=value2`\n\nAnd combine parameters\n\n`command -pjk`\n\n\n\nInstallation\n------------\n\nRun the following\n\n\tnpm install argr --save\n\n\n\nQuick Start\n-----------\n\nImport the definition\n\n\tvar Argr = require('argr');\n\nCreate in instance\n\n\tvar argr = Argr()\n\nDefine some **simple options**, to accept the following `hello -ab` and `hello --option_a --option_b` \n\n\t  .option(['a', 'option_a'], 'Option A')\n\t  .option(['b', 'option_b'], 'Option B')\n\nDefine an option with **complex syntax** specified with signature arguments: `-g -50.2 232` where `-g` option will always expect two additional values following\n\n\t  .option(['g', 'geocoord'], 'A geocoordinate', null, ['lat', 'lng'])\n\nDefine an option with **compact syntax**: `-s=abc-def` with default parameters\n\n\t  .option(['s', 'string'], 'A string', 'mydefaultstring')\n\nAnd initialize it (e.g. - `/usr/local/bin/node hello -abc -g -50.2 232 -s=abc-def`)\n\n\t.init('/usr/local/bin/node hello -abc -g -50.2 232 -s=abc-def');\n\nFull example: \n\n\tvar Argr = require('argr');\n\n\tArgr()\n\t  .option(['a', 'option_a'], 'Option A')\n\t  .option(['b', 'option_b'], 'Option B')\n\t  .useStrict(true)\n\t  .init('/usr/local/bin/node hello -ab');\n\nYou can retrieve the parameters like so\n\n\tassert.equal(argr.get('a'), true);\n\tassert.equal(argr.get('b'), true);\n\nUndefined parameters are not ignored\n\n\tassert.equal(argr.get('c'), true);\n\nAccess complex syntax with signatures as hash Objects\n\n\tassert.equal(argr.get('g').lat, '-50.2');\n\tassert.equal(argr.get('g').lng, '232');\n\nUse compact syntax with `{name}={value}`\n\n\tassert.equal(argr.get('s'), 'abc-def');\n\n\n\nArgr Class\n----------\n\nCreate an instance of argument parser.  \n\n\tvar Argr = require('argr');\n\tvar a = Argr().init(process.argv);\n\t\n\n\nargr.usedScript(flag)\n---------------------\n\n### flag {Boolean}\n\nA flag for command argument start, default true.  \n\nTrue assumes use of `/usr/local/bin/node` and starts parsing at index 2.  False starts parsing at index 1.  \n\nMust be set before `.init()`\n\n\tvar a = Argr()\n\t\t.usedScript(true)\n\t\t.init('/usr/local/bin/node hello -?');\n\n\n\nargr. useStrict(flag)\n---------------------\n\n### flag {Boolean}\n\nA flag to throw Error on undefined options, default false.  \n\n\tvar a = Argr()\n\t\t.useStrict(true)\n\t\t.init('/usr/local/bin/node hello -?');\n\nAn error is thrown if `?` is not defined through `argr.option()` during initialization.  \n\nMust be set before `.init()`\n\n\n\nargr.init(args)\n---------------\n\nInitialize, chainable\n\n### args {Mixed}\n\n`Object` Create an argument parser instance from `process.argv` argument vector.  \n\n\tvar Argr = require('argr');\n\tvar a = Argr().init(process.argv);\n\n`String` Or create an argument parser from string.\n\n\tvar Argr = require('argr');\n\tvar a = Argr().init('/usr/local/bin/node hello -f tests/data/config.json');\n\t\n\n\nargr.command()\n--------------\n\nGet command from argument vector.\n\n\tvar a = Argr().init('/use/local/bin/node hello -f tests/data/config.json');\n\tassert(a.command() === 'hello');\n\n\n\nargr.option(param, description, [values], [signature])\n--------------------------------------------------\n\nDefine an options and its syntax.  Arguments that are not define will be parsed anyway.  \n\nChainable\n\n### param {Mixed}\n\n`String` A parameter name \n\n\t// cmd -y\n\targr.option('y', 'Lorem ipsum')\n\n`Array` ['a', 'apple', alternate-form...] parameter name(s) and aliases\n\n\t// short: cmd -f\n\t//  long: cmd --fruit\n\targr.option(['f', 'fruit'], 'A fruit')\n\n### description {String}\n\nA description value\n\n### values {Mixed}\n\nAn optional set of default values\n\n`Boolean` A single default Boolean if no argument was passed\n\n`Number` A single default Number if no argument was passed\n \n`String` A single default String if no argument was passed\n\n`Array` A set of default values, intending to match a signature.  Uses the signature to create a hash of values using the signature as keys and the Array as values.  \n\n### signature {Array}\n\nAn optional argument signature.  Specifying a signature will expect the next argument(s) to be values.  \n\n\t// cmd -g -50.32 74.2 \n\targr.option(['g', 'geocoords'], 'A set of geocoordinates', null, ['lat', 'lng'])\n\nThe option `-g` will expect `lat` and `lng` coordinates when used; `argr.get('g')` returns:\n\n\t{\n\t\t'lat': '-50.32',\n\t\t'lng': '74.2'\n\t}\n\n\n\nargr.option(param)\n------------------\n\nGet a defined option parameter\n\n\targr.option('g')\n\nRetrieves a full description of the defined parameters\n\n\t{\n\t\tparam: ['g', 'geocoords'],\n\t\tvalue: {Function},\n\t\tsignature: ['lat', 'lng'],\n\t\tdescription: 'A set of geocoordinates'\n\t}\n\n### param {Mixed}\n\n`String` A name of a specific parameter\n\n`Array` A set of acceptable parameter names or aliases\n\n\n\nargr.options()\n--------------\n\nGet all defined options\n\n\ta.options()\n\nAll of the option definitions\n\n\n\nargr.get(name)\n--------------\n\nRetrieve parameters according to the name of the parameter.  Undefind parameters are returned as well but must still be prefixed with either `-` or `--` (e.g. - `--color`).  \n\n### name {String}\n\nA name of a specific parameter\n\n\n\n\nCombined parameters\n-------------------\n\n\tvar argr = Argr().init('/usr/local/bin/node cmd -zxvf');\n\nParameters can be combined for shorter syntax each will become parameters.  \n\n\tassert.equal(argr.get('z'), true);\n\tassert.equal(argr.get('x'), true);\n\tassert.equal(argr.get('v'), true);\n\tassert.equal(argr.get('f'), true);\n\n\n\nUndefined parameters are not ignored\n-------------------\n\nAny undefined arguments will still be retrievable using `.get('n')` where `'n'` is the name.  \n\n\n\nComplex syntax using signatures\n-------------------\n\n\tvar argr = Argr().init('/usr/local/bin/node cmd -g -50.32 74.2');\n\targr.option(['g', 'geocoords'], 'A set of geocoordinates', null, ['lat', 'lng'])\n\nUsing a signature will allow complex syntax returning the result as a hash where the keys are defined in the signature.  \n\n\tassert.equal(argr.get('g').lat, '-50.32');\n\tassert.equal(argr.get('g').lng, '74.2');\n\n\n\nCompact syntax\n-------------------\n\n\tvar argr = Argr().init('/usr/local/bin/node cmd -f=myfile.txt');\n\t\nCompact syntax allows the use of `[name]=[value]` pairs\n\n\tassert.equal(argr.get('f'), 'myfile.txt');\n\n\n\nLicense\n-------\n\nCopyright (c) 2014 Henry Tseng\n\nReleased under the MIT license. See LICENSE for details.\n",
  "readmeFilename": "README.md",
  "gitHead": "b44efc1c8a04c8caf09612fc82cf611c6e0fa989",
  "bugs": {
    "url": "https://github.com/henrytseng/argr/issues"
  },
  "homepage": "https://github.com/henrytseng/argr",
  "_id": "argr@1.1.7",
  "_shasum": "e13ca7472eee2ade5de9957699ffb2a3756b9124",
  "_from": "argr@>=1.1.7 <1.2.0"
}
